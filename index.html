<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>3D Grab-Pack Puzzle Chase (Starter)</title>
  <style>
    :root{ color-scheme:dark; }
    html,body{ height:100%; margin:0; background:#06070a; overflow:hidden; }
    #hud{
      position:fixed; left:12px; right:12px; top:12px;
      display:flex; gap:10px; align-items:center; justify-content:space-between;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      color:#d7dee6;
      pointer-events:none;
      z-index:10;
    }
    .pill{
      background:rgba(15,18,23,0.82);
      border:1px solid rgba(255,255,255,0.12);
      padding:8px 10px;
      border-radius:999px;
      backdrop-filter: blur(8px);
    }
    #msg{
      position:fixed; left:50%; top:64px; transform:translateX(-50%);
      max-width:min(920px, 94vw);
      background:rgba(10,12,16,0.72);
      border:1px solid rgba(255,255,255,0.12);
      border-radius:14px;
      padding:12px 14px;
      font-family: ui-sans-serif, system-ui;
      color:#d7dee6;
      display:none;
      z-index:10;
      pointer-events:none;
    }
    #crosshair{
      position:fixed; left:50%; top:50%; transform:translate(-50%,-50%);
      width:14px; height:14px; z-index:10; pointer-events:none;
      opacity:0.9;
    }
    #crosshair:before,#crosshair:after{
      content:""; position:absolute; left:50%; top:50%; background:#d7dee6;
      transform:translate(-50%,-50%);
    }
    #crosshair:before{ width:14px; height:2px; }
    #crosshair:after{ width:2px; height:14px; }
    #overlay{
      position:fixed; inset:0; display:grid; place-items:center;
      background:rgba(0,0,0,0.55);
      z-index:20;
      font-family: ui-sans-serif, system-ui;
      color:#d7dee6;
    }
    #card{
      width:min(820px, 92vw);
      background:rgba(15,18,23,0.9);
      border:1px solid rgba(255,255,255,0.12);
      border-radius:16px;
      padding:18px;
      box-shadow:0 20px 70px rgba(0,0,0,0.6);
    }
    #card h1{ margin:0 0 8px; font-size:26px; }
    #card p{ margin:8px 0; color:#aab9cc; line-height:1.35; }
    #card ul{ margin:10px 0 0 18px; color:#aab9cc; }
    #btn{
      margin-top:14px;
      display:inline-block;
      padding:10px 12px;
      border-radius:12px;
      background:#1b2433;
      border:1px solid rgba(255,255,255,0.14);
      color:#d7dee6;
      font-weight:700;
      cursor:pointer;
      pointer-events:auto;
    }
    #btn:hover{ filter:brightness(1.1); }
    canvas{ display:block; }
  </style>
</head>
<body>
  <div id="hud">
    <div class="pill"><b>WASD</b> move · <b>Shift</b> sprint · <b>Mouse</b> look · <b>Left/Right Click</b> hands · <b>R</b> retract · <b>E</b> interact</div>
    <div class="pill" id="status">Explore: 0/3</div>
  </div>
  <div id="msg"></div>
  <div id="crosshair"></div>

  <div id="overlay">
    <div id="card">
      <h1>3D Grab‑Pack Puzzle Chase (Starter)</h1>
      <p>This is an original 3D mini‑game scaffold (not using any Poppy assets). You solve 3 grab‑pack puzzles; the “monster” only appears in the final chase.</p>
      <ul>
        <li><b>Puzzle A</b>: pull a lever through a vent with a hand</li>
        <li><b>Puzzle B</b>: drag a crate onto a pressure plate</li>
        <li><b>Puzzle C</b>: tap power nodes in order 1→2→3</li>
      </ul>
      <div id="btn">Click to Start (Pointer Lock)</div>
      <p style="margin-top:10px; font-size:13px;">If your mouse won’t look around, click the game and accept pointer lock.</p>
    </div>
  </div>

  <!-- Three.js via CDN (works hosted). For offline you’d download these files. -->
  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
    import { PointerLockControls } from 'https://unpkg.com/three@0.160.0/examples/jsm/controls/PointerLockControls.js';

    // =============================
    // 0) Tiny UI helpers
    // =============================
    const statusEl = document.getElementById('status');
    const msgEl = document.getElementById('msg');
    const overlay = document.getElementById('overlay');
    const btn = document.getElementById('btn');

    const say = (text, seconds=3) => {
      if (!text){ msgEl.style.display = 'none'; return; }
      msgEl.textContent = text;
      msgEl.style.display = 'block';
      clearTimeout(say._t);
      say._t = setTimeout(() => { msgEl.style.display = 'none'; }, seconds*1000);
    };

    // =============================
    // 1) Renderer / Scene / Camera
    // =============================
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(Math.max(1, window.devicePixelRatio || 1));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x06070a);
    document.body.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x06070a, 4, 32);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.05, 120);
    camera.position.set(0, 1.6, 6);

    const controls = new PointerLockControls(camera, renderer.domElement);

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Lights
    scene.add(new THREE.HemisphereLight(0x9db0c5, 0x0b0c10, 0.7));
    const key = new THREE.DirectionalLight(0xffffff, 0.8);
    key.position.set(6, 10, 4);
    scene.add(key);

    // =============================
    // 2) Materials (simple “factory” look)
    // =============================
    const matWall = new THREE.MeshStandardMaterial({ color: 0x161b24, roughness: 0.95, metalness: 0.1 });
    const matFloor = new THREE.MeshStandardMaterial({ color: 0x0a0c10, roughness: 1.0, metalness: 0.0 });
    const matDoorClosed = new THREE.MeshStandardMaterial({ color: 0xe35b5b, roughness: 0.6, metalness: 0.1 });
    const matDoorOpen = new THREE.MeshStandardMaterial({ color: 0x51e39a, roughness: 0.6, metalness: 0.1, transparent:true, opacity:0.25 });
    const matInteract = new THREE.MeshStandardMaterial({ color: 0xf7c948, roughness: 0.5, metalness: 0.15 });
    const matCrate = new THREE.MeshStandardMaterial({ color: 0x273042, roughness: 0.9, metalness: 0.05 });
    const matGlass = new THREE.MeshStandardMaterial({ color: 0x9dd6ff, roughness: 0.05, metalness: 0.0, transparent:true, opacity:0.12 });

    // =============================
    // 3) World building helpers
    // =============================
    const colliders = []; // invisible boxes for collision
    const interactables = []; // raycast targets

    function addBox({x,y,z,w,h,d, material, collider=true, interactable=false, name=''}){
      const geo = new THREE.BoxGeometry(w,h,d);
      const mesh = new THREE.Mesh(geo, material);
      mesh.position.set(x,y,z);
      mesh.name = name;
      scene.add(mesh);
      if (collider){
        const box = new THREE.Box3().setFromObject(mesh);
        colliders.push({ mesh, box });
      }
      if (interactable){
        mesh.userData.interactable = true;
        interactables.push(mesh);
      }
      return mesh;
    }

    function updateColliderBoxes(){
      for (const c of colliders){
        c.box.setFromObject(c.mesh);
      }
    }

    // Floor
    const floor = new THREE.Mesh(new THREE.PlaneGeometry(60,60), matFloor);
    floor.rotation.x = -Math.PI/2;
    scene.add(floor);

    // Map layout in 3D (simple rooms/corridors)
    // Coordinates are x,z on floor. y is height.

    // Outer walls
    addBox({x:0,y:1.5,z:0,w:26,h:3,d:0.4,material:matWall}); // back
    addBox({x:0,y:1.5,z:12,w:26,h:3,d:0.4,material:matWall}); // front
    addBox({x:-13,y:1.5,z:6,w:0.4,h:3,d:24,material:matWall}); // left
    addBox({x:13,y:1.5,z:6,w:0.4,h:3,d:24,material:matWall}); // right

    // Interior dividers to make 3 wings
    addBox({x:-3,y:1.5,z:6,w:0.4,h:3,d:10,material:matWall});
    addBox({x:5,y:1.5,z:6,w:0.4,h:3,d:10,material:matWall});

    // Glass observation room (for hints)
    addBox({x:-8,y:1.5,z:7.5,w:6,h:3,d:0.25,material:matGlass, collider:false});
    addBox({x:-11,y:1.5,z:9,w:0.25,h:3,d:3,material:matGlass, collider:false});
    addBox({x:-5,y:1.5,z:9,w:0.25,h:3,d:3,material:matGlass, collider:false});

    // Doors (A, B, EXIT)
    const doorA = addBox({x:-3,y:1.2,z:2.2,w:0.35,h:2.4,d:1.4,material:matDoorClosed, collider:true, interactable:false, name:'doorA'});
    const doorB = addBox({x:5,y:1.2,z:2.2,w:0.35,h:2.4,d:1.4,material:matDoorClosed, collider:true, interactable:false, name:'doorB'});
    const doorExit = addBox({x:11.6,y:1.2,z:6.0,w:0.35,h:2.4,d:2.4,material:matDoorClosed, collider:true, interactable:false, name:'doorExit'});

    const doors = {
      A: { mesh: doorA, open:false },
      B: { mesh: doorB, open:false },
      EXIT: { mesh: doorExit, open:false },
    };

    function setDoor(keyName, isOpen){
      const d = doors[keyName];
      d.open = isOpen;
      d.mesh.material = isOpen ? matDoorOpen : matDoorClosed;
      // If open, remove collider effect by marking collider false-ish: we’ll keep box but ignore in collision
      d.mesh.userData.open = isOpen;
    }

    // =============================
    // 4) Player movement + collision
    // =============================
    const keys = new Set();
    window.addEventListener('keydown', (e)=>keys.add(e.key.toLowerCase()));
    window.addEventListener('keyup', (e)=>keys.delete(e.key.toLowerCase()));

    const player = {
      radius: 0.35,
      height: 1.6,
      vel: new THREE.Vector3(),
      speed: 3.2,
      sprint: 5.0,
    };

    // Simple capsule-like collision approximation: check camera position against collider boxes in XZ
    function resolveCollision(pos){
      const p = pos.clone();
      for (const c of colliders){
        // Skip open doors
        if (c.mesh.userData.open) continue;
        c.box.setFromObject(c.mesh);

        // Shrink test to XZ
        const min = c.box.min;
        const max = c.box.max;
        const closestX = Math.max(min.x, Math.min(p.x, max.x));
        const closestZ = Math.max(min.z, Math.min(p.z, max.z));
        const dx = p.x - closestX;
        const dz = p.z - closestZ;
        const dist2 = dx*dx + dz*dz;
        const r = player.radius;
        if (dist2 < r*r){
          const dist = Math.sqrt(dist2) || 0.0001;
          const push = (r - dist);
          p.x += (dx/dist) * push;
          p.z += (dz/dist) * push;
        }
      }
      return p;
    }

    // =============================
    // 5) Grab‑Pack hands (raycast + tether visuals)
    // =============================
    const raycaster = new THREE.Raycaster();

    function makeHand(side){
      const color = side==='L' ? 0x4aa3ff : 0xff4a7a;
      const lineMat = new THREE.LineBasicMaterial({ color, transparent:true, opacity:0.9 });
      const lineGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(), new THREE.Vector3()]);
      const line = new THREE.Line(lineGeo, lineMat);
      scene.add(line);

      const tip = new THREE.Mesh(new THREE.SphereGeometry(0.08, 16, 12), new THREE.MeshStandardMaterial({ color }));
      scene.add(tip);

      return {
        side,
        state: 'READY', // READY -> FLY -> LATCH -> RETRACT
        maxDist: 6.5,
        speed: 18,
        origin: new THREE.Vector3(),
        tip: tip.position,
        line,
        lineGeo,
        latched: null, // object
        latchPoint: new THREE.Vector3(),
        t: 0,
      };
    }

    const handL = makeHand('L');
    const handR = makeHand('R');

    function handOrigin(out){
      // Offset from camera (like a backpack mount)
      const right = new THREE.Vector3(1,0,0).applyQuaternion(camera.quaternion);
      const up = new THREE.Vector3(0,1,0);
      const fwd = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion);
      const side = out === handL ? -1 : 1;
      return camera.position.clone()
        .add(right.multiplyScalar(0.18 * side))
        .add(up.multiplyScalar(-0.12))
        .add(fwd.multiplyScalar(0.22));
    }

    function fireHand(hand){
      if (state !== 'EXPLORE' && state !== 'CHASE') return;
      if (hand.state !== 'READY') return;

      const o = handOrigin(hand);
      hand.origin.copy(o);
      hand.tip.copy(o);
      hand.t = 0;
      hand.latched = null;

      // Raycast from center crosshair
      raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
      const hits = raycaster.intersectObjects(interactables, false);
      const target = hits.length ? hits[0] : null;

      if (target && target.distance <= hand.maxDist){
        // Fly to hit point, then latch
        hand.state = 'FLY';
        hand.latchPoint.copy(target.point);
        hand.latched = target.object;
      } else {
        // Fly to max distance point in view direction
        hand.state = 'FLY';
        const dir = raycaster.ray.direction.clone();
        hand.latchPoint.copy(o).add(dir.multiplyScalar(hand.maxDist));
        hand.latched = null;
      }
    }

    function retractHand(hand){
      hand.state = 'RETRACT';
      hand.latched = null;
    }

    function updateHand(hand, dt){
      const o = handOrigin(hand);
      hand.origin.copy(o);

      if (hand.state === 'READY'){
        hand.tip.copy(o);
      }

      if (hand.state === 'FLY'){
        hand.t = Math.min(1, hand.t + dt * 6);
        hand.tip.lerpVectors(o, hand.latchPoint, hand.t);
        if (hand.t >= 1){
          // If latched to something interactable, latch
          if (hand.latched){
            hand.state = 'LATCH';
          } else {
            hand.state = 'RETRACT';
          }
        }
      }

      if (hand.state === 'LATCH'){
        // Keep tip at latch point
        hand.tip.copy(hand.latchPoint);

        // Special behaviors based on latched object name
        const obj = hand.latched;
        if (!obj) { hand.state = 'RETRACT'; }
      }

      if (hand.state === 'RETRACT'){
        hand.tip.lerp(o, Math.min(1, dt*14));
        if (hand.tip.distanceTo(o) < 0.12){
          hand.state = 'READY';
          hand.tip.copy(o);
        }
      }

      // Update line geometry
      const pts = [hand.origin.clone(), hand.tip.clone()];
      hand.lineGeo.setFromPoints(pts);
      hand.lineGeo.computeBoundingSphere();
    }

    window.addEventListener('mousedown', (e)=>{
      if (e.button===0) fireHand(handL);
      if (e.button===2) fireHand(handR);
    });
    window.addEventListener('contextmenu', (e)=>e.preventDefault());

    // =============================
    // 6) Puzzles (A lever, B plate, C power nodes)
    // =============================
    const solved = { A:false, B:false, C:false };

    // A) Lever: behind a wall; only reachable through a “vent” gap area.
    // We fake this by making the lever target interactable but placing it in a niche.
    addBox({x:-9.4,y:1.2,z:9.0,w:6,h:2.4,d:0.4,material:matWall}); // back wall in left wing

    // Vent frame (visual)
    addBox({x:-7.8,y:1.3,z:8.75,w:1.4,h:0.8,d:0.18,material:matWall, collider:false});

    // Lever target (interactable)
    const lever = addBox({x:-7.8,y:1.3,z:8.6,w:0.22,h:0.22,d:0.22,material:matInteract, collider:false, interactable:true, name:'lever'});
    lever.userData.kind = 'lever';

    // B) Crate + Plate
    const crate = addBox({x:7.6,y:0.5,z:10.2,w:0.8,h:0.8,d:0.8,material:matCrate, collider:true, interactable:true, name:'crate'});
    crate.userData.kind = 'crate';

    const plate = addBox({x:7.8,y:0.05,z:7.2,w:1.4,h:0.12,d:1.0,material:new THREE.MeshStandardMaterial({ color:0x2a3345, roughness:0.7, metalness:0.05 }), collider:false, interactable:false, name:'plate'});
    plate.userData.pressed = false;

    // C) Power nodes order 1->2->3
    const powerNodes = [
      { pos: new THREE.Vector3(9.5, 1.3, 2.8), on:false, idx:0 },
      { pos: new THREE.Vector3(10.7,1.3, 4.0), on:false, idx:1 },
      { pos: new THREE.Vector3(9.9, 1.3, 5.2), on:false, idx:2 },
    ];
    const nodeMeshes = powerNodes.map((n,i)=>{
      const m = new THREE.Mesh(new THREE.SphereGeometry(0.18, 18, 14), new THREE.MeshStandardMaterial({ color:0x4a5873, roughness:0.4, metalness:0.2 }));
      m.position.copy(n.pos);
      m.userData.kind = 'node';
      m.userData.nodeIndex = i;
      m.userData.interactable = true;
      scene.add(m);
      interactables.push(m);
      return m;
    });
    let nodeOrder = 0;

    // Hint props (no monster shown)
    const note = addBox({x:-10.8,y:1.1,z:4.0,w:0.8,h:0.8,d:0.05,material:new THREE.MeshStandardMaterial({ color:0xd7dee6, roughness:0.9, metalness:0.0 }), collider:false, interactable:true, name:'note'});
    note.userData.kind = 'note';

    const glassPanel = addBox({x:-8.0,y:1.5,z:7.5,w:6.2,h:2.6,d:0.06,material:matGlass, collider:false, interactable:false});

    // Exit zone (a glowing rectangle on the floor)
    const exitZone = new THREE.Mesh(new THREE.PlaneGeometry(2.4,2.4), new THREE.MeshStandardMaterial({ color:0x9dd6ff, transparent:true, opacity:0.18 }));
    exitZone.rotation.x = -Math.PI/2;
    exitZone.position.set(10.6, 0.01, 6.0);
    scene.add(exitZone);

    // =============================
    // 7) Interaction + Grab behaviors
    // =============================
    function updateStatus(){
      const n = Object.values(solved).filter(Boolean).length;
      statusEl.textContent = (state==='CHASE') ? 'RUN!' : `Explore: ${n}/3`;
      // Exit door opens only when all solved
      const all = solved.A && solved.B && solved.C;
      setDoor('EXIT', all);
    }

    // Carry/drag crate with a hand while latched
    function pullCrateToward(hand, dt){
      // Move crate toward hand tip with simple smoothing
      const to = hand.tip.clone();
      to.y = crate.position.y;
      crate.position.lerp(to, Math.min(1, dt*5.5));
    }

    function pressPlateCheck(){
      // Check crate over plate
      const dx = Math.abs(crate.position.x - plate.position.x);
      const dz = Math.abs(crate.position.z - plate.position.z);
      const on = dx < 0.75 && dz < 0.55;
      if (on && !solved.B){
        solved.B = true;
        plate.material.color.setHex(0x51e39a);
        setDoor('B', true);
        say('Plate pressed. Door B unlocked.', 2.2);
        updateStatus();
      }
      plate.userData.pressed = on;
    }

    function doNodeTap(i){
      if (solved.C) return;
      if (i === nodeOrder){
        nodeMeshes[i].material.color.setHex(0x51e39a);
        nodeOrder++;
        say('Power node connected.', 1.2);
        if (nodeOrder >= nodeMeshes.length){
          solved.C = true;
          say('Power restored. Something woke up…', 2.6);
          updateStatus();
        }
      } else {
        // reset
        nodeOrder = 0;
        for (const m of nodeMeshes) m.material.color.setHex(0x4a5873);
        say('Sequence reset.', 1.2);
      }
    }

    // Apply latch effects based on object
    function applyLatchEffects(hand, dt){
      if (hand.state !== 'LATCH' || !hand.latched) return;
      const kind = hand.latched.userData.kind;

      if (kind === 'lever'){
        // If player backs away while latched, lever flips
        const dist = hand.origin.distanceTo(hand.tip);
        if (dist > 4.8 && !solved.A){
          solved.A = true;
          lever.material.color.setHex(0x51e39a);
          setDoor('A', true);
          say('Lever pulled. Door A unlocked.', 2.2);
          updateStatus();
          retractHand(hand);
        }
      }

      if (kind === 'crate'){
        pullCrateToward(hand, dt);
      }

      if (kind === 'node'){
        doNodeTap(hand.latched.userData.nodeIndex);
        retractHand(hand);
      }

      if (kind === 'note'){
        say("A note: 'If you hear dragging… don’t look for it.'", 3.2);
        retractHand(hand);
      }
    }

    // When hand finishes flying, convert to latch on actual hit object
    function tryFinalizeLatch(hand){
      if (hand.state !== 'FLY' || hand.t < 1) return;
      // If we targeted an interactable, keep latched; else retract
      if (hand.latched){
        // Recompute latch point to the object’s current position if it’s a crate
        if (hand.latched.userData.kind === 'crate'){
          hand.latchPoint.copy(crate.position);
          hand.latchPoint.y = crate.position.y + 0.1;
        }
        hand.state = 'LATCH';
      } else {
        hand.state = 'RETRACT';
      }
    }

    // Retract key
    window.addEventListener('keydown', (e)=>{
      if (e.key.toLowerCase()==='r') { retractHand(handL); retractHand(handR); }
    });

    // =============================
    // 8) Monster (ONLY in final chase)
    // =============================
    const monster = new THREE.Mesh(
      new THREE.SphereGeometry(0.55, 22, 16),
      new THREE.MeshStandardMaterial({ color: 0x0b0c0f, roughness: 0.6, metalness: 0.0 })
    );
    monster.visible = false;
    monster.position.set(11.0, 0.55, 11.2);
    scene.add(monster);

    const monsterData = {
      active:false,
      speed: 4.2,
    };

    function startChase(){
      if (state !== 'EXPLORE') return;
      state = 'CHASE';
      monster.visible = true;
      monsterData.active = true;
      say('DON’T LOOK BACK. GET TO THE EXIT.', 3.0);
      updateStatus();
    }

    function updateMonster(dt){
      if (!monsterData.active) return;
      const toPlayer = new THREE.Vector3().subVectors(camera.position, monster.position);
      toPlayer.y = 0;
      const dist = toPlayer.length();
      if (dist > 0.001) toPlayer.normalize();
      monster.position.add(toPlayer.multiplyScalar(monsterData.speed * dt));

      // Collision-ish: keep monster inside bounds by clamping a bit
      monster.position.x = THREE.MathUtils.clamp(monster.position.x, -12.0, 12.0);
      monster.position.z = THREE.MathUtils.clamp(monster.position.z, 0.6, 11.6);

      // Catch
      const dx = monster.position.x - camera.position.x;
      const dz = monster.position.z - camera.position.z;
      if ((dx*dx + dz*dz) < (0.75*0.75)){
        // Soft reset (no graphic violence)
        say('Caught. Resetting…', 2.0);
        resetToExplore(true);
      }
    }

    function resetToExplore(keepSolved=true){
      state = 'EXPLORE';
      monsterData.active = false;
      monster.visible = false;
      monster.position.set(11.0, 0.55, 11.2);
      camera.position.set(0, 1.6, 6);
      player.vel.set(0,0,0);
      retractHand(handL); retractHand(handR);
      if (!keepSolved){
        solved.A = solved.B = solved.C = false;
        nodeOrder = 0;
        lever.material.color.setHex(0xf7c948);
        plate.material.color.setHex(0x2a3345);
        for (const m of nodeMeshes) m.material.color.setHex(0x4a5873);
        setDoor('A', false); setDoor('B', false); setDoor('EXIT', false);
      }
      say('The building is louder now…', 2.2);
      updateStatus();
    }

    // =============================
    // 9) Game state & win
    // =============================
    let state = 'TITLE'; // TITLE -> EXPLORE -> CHASE -> WIN

    function checkHints(){
      if (state !== 'EXPLORE') return;

      // Hint 1: glass “movement” line (text only)
      const nearGlass = camera.position.distanceTo(new THREE.Vector3(-8,1.6,7.5)) < 2.2;
      if (nearGlass && !checkHints._glass){
        checkHints._glass = true;
        say('Behind the glass: something moved… maybe just your eyes.', 3.0);
      }

      // Hint 2: “shadow” (text only)
      const nearShadow = camera.position.distanceTo(new THREE.Vector3(-2,1.6,10.8)) < 2.0;
      if (nearShadow && !checkHints._shadow){
        checkHints._shadow = true;
        say('A shadow slides along the floor, then stops.', 2.8);
      }

      // Start chase only when all puzzles solved and you approach the EXIT door area
      const all = solved.A && solved.B && solved.C;
      if (all){
        const nearExitDoor = camera.position.distanceTo(new THREE.Vector3(11.0,1.6,6.0)) < 2.1;
        if (nearExitDoor && state==='EXPLORE') startChase();
      }
    }

    function checkWin(){
      if (state !== 'CHASE') return;
      const dx = camera.position.x - exitZone.position.x;
      const dz = camera.position.z - exitZone.position.z;
      if ((dx*dx + dz*dz) < (1.15*1.15)){
        state = 'WIN';
        monsterData.active = false;
        monster.visible = false;
        overlay.style.display = 'grid';
        document.getElementById('card').innerHTML = `
          <h1>YOU ESCAPED</h1>
          <p>Nice. Want me to add a second level, sound, and a scarier chase pathing?</p>
          <div id="btn">Play Again</div>
        `;
        const b = document.getElementById('btn');
        b.addEventListener('click', ()=>{
          overlay.style.display = 'none';
          resetToExplore(true);
        });
      }
    }

    // =============================
    // 10) Start button / pointer lock
    // =============================
    btn.addEventListener('click', () => {
      controls.lock();
    });

    controls.addEventListener('lock', () => {
      overlay.style.display = 'none';
      if (state === 'TITLE'){
        state = 'EXPLORE';
        say('Find three locks: LEVER, PLATE, POWER.', 3.2);
        updateStatus();
      }
    });

    controls.addEventListener('unlock', () => {
      // Show overlay pause
      if (state !== 'WIN') overlay.style.display = 'grid';
    });

    // =============================
    // 11) Animation loop
    // =============================
    const clock = new THREE.Clock();

    function animate(){
      const dt = Math.min(0.033, clock.getDelta());

      // Movement
      if (controls.isLocked && (state==='EXPLORE' || state==='CHASE')){
        const forward = new THREE.Vector3();
        camera.getWorldDirection(forward);
        forward.y = 0; forward.normalize();
        const right = new THREE.Vector3().crossVectors(forward, new THREE.Vector3(0,1,0)).multiplyScalar(-1).normalize();

        const speed = keys.has('shift') ? player.sprint : player.speed;
        const wish = new THREE.Vector3();
        if (keys.has('w')) wish.add(forward);
        if (keys.has('s')) wish.add(forward.clone().multiplyScalar(-1));
        if (keys.has('a')) wish.add(right.clone().multiplyScalar(-1));
        if (keys.has('d')) wish.add(right);
        if (wish.lengthSq() > 0){
          wish.normalize().multiplyScalar(speed * dt);
          const next = camera.position.clone().add(new THREE.Vector3(wish.x, 0, wish.z));
          const resolved = resolveCollision(next);
          camera.position.copy(resolved);
        }
      }

      // Hands
      updateHand(handL, dt);
      updateHand(handR, dt);
      tryFinalizeLatch(handL);
      tryFinalizeLatch(handR);
      applyLatchEffects(handL, dt);
      applyLatchEffects(handR, dt);

      // Keep latch points on moving crate
      if (handL.state==='LATCH' && handL.latched?.userData.kind==='crate'){
        handL.latchPoint.copy(crate.position).add(new THREE.Vector3(0,0.12,0));
      }
      if (handR.state==='LATCH' && handR.latched?.userData.kind==='crate'){
        handR.latchPoint.copy(crate.position).add(new THREE.Vector3(0,0.12,0));
      }

      // Puzzle checks
      pressPlateCheck();
      checkHints();

      // Monster
      updateMonster(dt);

      // Win
      checkWin();

      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }

    // Doors initial
    setDoor('A', false);
    setDoor('B', false);
    setDoor('EXIT', false);
    updateStatus();
    say('', 0);

    animate();
  </script>
</body>
</html>
